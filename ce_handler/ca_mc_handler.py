#TODO
    def _enum_configs_under_sccomp(self,sc_mat,comp,eq_occu=None):
        """
        Built in method to generate occupations under a supercell matrix and a fixed composition.
        Assuming that atoms in the supercells are generated by pymatgen.structure.make_supercell
        from the primitive cell, which simply replicates and stacks atom in their initial order.
        For example: [Ag, Cu] -> [Ag, Ag, Cu, Cu]

        Inputs:
            sc_mat(3*3 ArrayLike):
                Supercell matrix
            comp(Union([List[pymatgen.Composition],List[SiteSpace], List[dict] ])):
                Compositions on each sublattice. Fractional.           
            eq_occu(List of ints):
                Occupation array of ground state under that composition. If None, will anneal to
                calculate
        Return:
            rand_strs_dedup:
                List of deduped pymatgen.Structures
            rand_occus_dedup:
                List of deduped occupation arrays. All in list of ints.
            comp_weight:
                Total number of all possible structures with the current composition.
                Integer.
        """

        print("\nEnumerating under supercell: {}, composition: {}.".format(sc_mat,comp))
 
        is_indicator = (self.basis_type == 'indicator')
        scs = int(round(abs(np.linalg.det(sc_mat))))

        #Anneal n_atoms*100 per temp, Sample n_atoms*500, give 100 samples for practical ccomputation
        n_steps_anneal = scs*len(self.prim)*100
        n_steps_sample = scs*len(self.prim)*500
        thin = max(1,n_steps_sample//100)

        anneal_series = [2000,1340,1020,700,440,280,200,120,80,20]
        sample_series = [500,1500,10000]

        ensemble = CanonicalEnsemble.from_cluster_expansion(self.ce, sc_mat, 
                                                            optimize_inidicator=is_indicator)
        sampler = Sampler.from_ensemble(ensemble,temperature=1000)
        processor = ensemble.processor
        sm = StructureMatcher()
 
        print("**Initializing occupation.")
        init_occu = self._initialize_occu_under_sccomp(sc,comp)
 
        if eq_occu is None:
        #If not annealed before, will anneal and save GS
            print("****Annealing to the ground state.")
            sampler.anneal(anneal_series,n_steps_anneal,
                           initial_occupancies=np.array([init_occu]))
 
            print('*****Equilibrium GS found!')
            gs_occu = list(sampler.samples.get_minimum_energy_occupancy())
        else:
        #If annealed before, will use old GS
            gs_occu = eq_occu
 
        #Will always contain GS structure at the first position in list
        rand_occus = [gs_occu]
        #Sampling temperatures
        
        for T in sample_series:
            print('**Getting samples under {} K.'.format(T))
            sampler.samples.clear()
            sampler._kernel.temperature = T
            #Equilibriate
            print("****Equilibration run.")
            sampler.run(n_steps_sample,
                        initial_occupancies=np.array([gs_occu]),
                        thin_by=thin,
                        progress=True)
            sa_occu = sampler.samples.get_occupancies()[-1]
            sampler.samples.clear()
            #Sampling
            print("****Generative run.")
            sampler.run(n_steps_sample,
                        initial_occupancies=np.array([sa_occu]),
                        thin_by=thin,
                        progress=True)
            #default flat=True will remove n_walkers dimension. See moca docs.
            rand_occus.extend(np.array(sampler.samples.get_occupancies()).tolist())          

        rand_strs = [processor.structure_from_occupancy(occu) for occu in rand_occus]
        #Internal deduplication
        rand_dedup = []
        for s1_id,s1 in enumerate(rand_strs):
            duped = False
            for s2_id,s2 in enumerate(rand_dedup):
                if sm.fit(s1,s2):
                    duped = True
                    break
            if not duped:
                rand_dedup.append(s1_id)

        print('{} unique structures generated.'.format(len(rand_dedup)))
        rand_strs_dedup = [rand_strs[s_id] for s_id in rand_dedup]
        rand_occus_dedup = [rand_occus[s_id] for s_id in rand_dedup]

        return rand_strs_dedup, rand_occus_dedup

    def _initialize_occu_under_sccomp(self,sc_mat,comp):
        """
        Get an initial occupation under certain supercell matrix and composition.
        Composition must be pre_nomalized into fractional form.
        If n_atoms is not 1, then the rest will be filled with Vacancy().
        Inputs:
            sc_mat(3*3 ArrayLike):
                Supercell matrix
            comp(Union([List[pymatgen.Composition],List[SiteSpace], List[dict] ])):
                Compositions on each sublattice. Fractional.
        Output:
            init_occu:
                Arraylike of integers. Encoded occupation array.
            comp_weight:
                Total number of all possible structures with the current composition.
                Integer.
        """
        scs = int(round(abs(np.linalg.det(sc_mat))))
        
        sc_sublat_list = []
        #Generating sublattice list for a supercell, to be used in later radomization code.
        for sl in self.sublat_list:
            sl_sites = []
            for s in sl:
                sl_sites.extend(list(range(s*scs,(s+1)*scs)))
            sc_sublat_list.append(sl_sites)

        #randomly initalize 50 occus, pick 10 with lowest ewald energy (if is_charged_ce),
        #Then choose one final as initalization randomly
        int_comp = []
        for sl_frac_comp, sl_sites in zip(comp,sc_sublat_list):

            if sum(sl_frac_comp.values())<1 and sum(sl_frac_comp.values())>=0:
                x_vac_add = 1-sum(sl_frac_comp.values())
            elif sum(sl_frac_comp.values())==1:
                pass
            else:
                raise ValueError('Composition {} not a proper normalized composition!'.format(sl_frac_comp))

            sl_int_comp = {}
            vac_key = None
            for k,v in sl_frac_comp.items():
            #Tolerance of irrational compositions
                if abs(v*len(sl_sites)-round(v*len(sl_sites)))>0.1:
                    raise ValueError("Sublattice compostion {} can not be achieved with sublattice size {}."\
                                     .format(sl_frac_comp,len(sl_sites)))
                sl_int_comp[k] = int(round(v*len(sl_sites)))
                if isinstance(k,Vacancy):
                    vac_key = k
            #Fraction <1 filled with vacancies
            if vac_key is not None:
                sl_int_comp[vac_key]+= int(round(x_vac_add*len(sl_sites)))
            else:
                sl_int_comp[Vacancy()] = int(round(x_vac_add*len(sl_sites)))
            
            int_comp.append(sl_int_comp)

        rand_occus = []
        for i in range(50):
            #Occupancy is coded
            occu = [None for i in range(len(self.prim)*scs)]
            for sl_id, (sl_int_comp, sl_sites) in enumerate(zip(int_comp,sc_sublat_list)):
                sl_sites_shuffled = random.shuffle(deepcopy(sl_sites))

                n_assigned = 0
                for sp,n_sp in sl_int_comp.items():
                    for s_id in sl_sites_shuffled[n_assigned:n_assigned+n_sp]:
                        sp_name = get_species(sp)
                        sp_id = self.bits[sl_id].index(sp_name)
                        occu[s_id] = sp_id
                    n_assigned += n_sp

            for sp in occu:
                if sp is None:
                    raise ValueError("Unassigned site in occupation: {}, composition is: {}!".format(occu,comp))    

            rand_occus.append(occu)

        if self.is_charged_ce:
            rand_occus = sorted(rand_occus,key=lambda occu:\
                                get_ewald_from_occu(occu,sc_sublat_list,self.bits,self.prim,sc_mat))

        return random.choice(rand_occus[:10]), comp_weight

